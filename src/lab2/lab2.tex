\documentclass[a4paper]{article}
\usepackage{minted}

\usepackage{polski}
\usepackage[utf8]{inputenc}

\usepackage[export]{adjustbox}
\usepackage{scrextend}
\usepackage{amsfonts}
\usepackage{amsmath}


\usepackage{geometry}
\geometry{a4paper, left=15mm, top=30mm, right=15mm, bottom=20mm}

\usepackage{gensymb}
\usepackage{graphicx} 
\usepackage{isotope}
\usepackage{array}
\usepackage{float}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{multirow}

\usepackage{hyperref}
\usepackage{sectsty}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[labelformat=simple]{subcaption}
\usepackage{xcolor,colortbl}


\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [
    rectangle, 
    rounded corners, 
    minimum width=3cm, minimum height=1cm,
    text centered,
    draw=black, fill=red!30]
\tikzstyle{io} = [
    trapezium, trapezium left angle=70, trapezium right angle=110, 
    minimum width=3cm, minimum height=1cm, 
    text centered, 
    draw=black, fill=blue!30]
\tikzstyle{process} = [
    rectangle, 
    minimum width=3cm, minimum height=1cm, 
    text centered, 
    draw=black, fill=orange!30]
\tikzstyle{decision} = [
    diamond, 
    minimum width=3cm, minimum height=1cm, 
    text centered, 
    draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\usepackage{karnaugh-map}

\sectionfont{\normalfont\huge\sectionrule{0pt}{0pt}{-6pt}{1pt}}
\subsectionfont{\normalfont\LARGE}
\subsubsectionfont{\normalfont\Large}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,LO]{\Large Łukasz Kwinta, Kacper Kozubowski, Ida Ciepiela}
\fancyhead[LE,RO]{\Large Układ odliczający}
\fancyfoot[CE,CO]{\Large\thepage}

\renewcommand{\footrulewidth}{1pt}
\renewcommand{\headrulewidth}{1pt}

\definecolor{Gray}{gray}{0.85}
\definecolor{LightGray}{gray}{0.95}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\counterwithin{table}{section}
\counterwithin{figure}{section}

\title{\fontsize{30pt}{30pt}\selectfont Laboratorium 2 \\ Układ odliczający}
\author{\fontsize{20pt}{20pt}\selectfont Łukasz Kwinta, Kacper Kozubowski, Ida Ciepiela}
\date{kwiecień 2024}

\begin{document}
\maketitle
\pagebreak
\large
\tableofcontents

\pagebreak
\section{Cel zadania}
\Large
Korzystając wyłącznie z wybranych przerzutników oraz dowolnych bramek logicznych, proszę zaprojektować czterobitowy układ TIMER, odmierzający ustawiany za pomocą przełączników czas (od 0 do 15).
\\\\
Po wciśnięciu przycisku STRAT, układ rozpoczyna odmierzanie czasu do tyłu (proszę dobrać częstotliwość tak, aby efekt był dobrze widoczny na ekranie). 
\\\\
Po wyzerowaniu się licznika czasu, układ powinien się zatrzymać i włączyć alarm świetlny wykorzystujący diodę LED. Po ponownym wciśnięciu przycisku START, 
układ powinien wyłączyć alarm i ponownie rozpocząć odmierzanie ustawionego na przełącznikach czasu.
Aktualny wskazywany przez układ czas proszę pokazywać na wyświetlaczach siedmiosegmentowych.

\section{Idea rozwiązania}
Do rozwiązania zadania wybraliśmy przerzutniki T - z powodu łatwości sterowania takim układem. Do sterowania przerzutnikami
w trybie synchronicznym wykorzystaliśmy transkoder uruchamiający wejścia T kolejnych przerzutników na bazie obecnego 
stanu wyjścia układu. Dodatkowo dodaliśmy pojedynczy sygnał kontrolujący włączenie/wyłączenie układu.

Do początkowego zaprogramowania czasu odliczania na liczniku wykorzystaliśmy możliwość asynchronicznego ustawienia przerzutników
w konkretny stan, również tutaj zaprojektowaliśmy transkoder, który porównuje stan przerzutników z wejściem do programowania 
czasu i odpowiednio ustawia układ. 

\pagebreak
\section{Układ timer}
\subsection{Black box}
Pierwszym krokiem w projektowaniu układu było zaprojektowanie czarnej skrzynki i określenie wejść i wyjść 
układu.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{timer_black_box.png}
    \captionof{figure}{Czarna skrzynka timera}
\end{figure}

Poniżej przedstawimy specyfikację wejść i wyjść układu
\subsubsection{Wejścia}
\begin{itemize}
    \item \verb|INx| - wejścia programujące czas odliczania licznika - binarny zapis liczby od której licznik powinien 
            zacząć odliczać. 4 wejścia łącznie pozwalają na odliczanie w zakresie 0-15. \verb|IN0| oznacza najmniej 
            znaczący bit, \verb|IN3| oznacza najbardziej znaczący bit. Wejście jest używane do zaprogramowania w momencie
            gdy na wejściu \verb|START| pojawi się stan wysoki.
            \begin{center}
                \begin{tabular}{|c|c|c|c|c|}
                  \hline Numer bitu & 3 & 2 & 1 & 0 \\ 
                  \hline Bit & \verb|IN3| & \verb|IN2| & \verb|IN1| & \verb|IN0| \\
                  \hline Mnożnik & $2^3$ & $2^2$ & $2^1$ & $2^0$  \\
                  \hline
                \end{tabular}
                \captionof{table}{Kodowanie pinów wejściowych} 
              \end{center}

    \item \verb|START| - wejście aktywujące układ. Stan wysoki oznacza aktywację licznika, stan niski oznacza, że licznik 
              dokończy liczenie do wyzerowania licznika.

              Jeśli wejście \verb|START| będzie miało stan wysoki w czasie dojścia licznika do zera, na wyjściu \verb|ALARM|
              pojawi się puls, po czym licznik zostanie zaprogramowany obecnym wejściem, a następnie uruchomiony ponownie.
              
              Zmiany stanu na wejściu \verb|START| w czasie gdy licznik jest w stanie liczenia, nie mają żadnego efektu. 

    \item \verb|CLK| - wejście zegara stanowiącego podstawę czasu licznika - określa jak szybko następować będą zmiany wyjścia
              i odliczanie licznika do zera.
\end{itemize}

\subsubsection{Wyjścia}
\begin{itemize}
    \item \verb|OUTx| - wyjścia stanowiące kolejne bity aktualnego stanu licznika. Zmiana wartości licznika, następuje
            na wznoszącym zboczu zegara wejściowego. \verb|OUT0| stanowi najmniej znaczący bit, a \verb|OUT3| najbardziej
            znaczący bit.
            \begin{center}
                \begin{tabular}{|c|c|c|c|c|}
                  \hline Numer bitu & 3 & 2 & 1 & 0 \\ 
                  \hline Bit & \verb|OUT3| & \verb|OUT2| & \verb|OUT1| & \verb|OUT0| \\
                  \hline Mnożnik & $2^3$ & $2^2$ & $2^1$ & $2^0$  \\
                  \hline
                \end{tabular}
                \captionof{table}{Kodowanie pinów wejściowych} 
              \end{center}
              
    \item \verb|ALARM| - wyjście sygnalizujące zakończenie odliczania licznika. Stan wysoki oznacza, że obecny stan licznika
              jest równy 0.

\end{itemize}

\pagebreak
\subsection{Diagram załączania układów}
Poniżej rozpisaliśmy diagram zależności stanu załączenia poszczególnych układów od siebie z którego wynikać będą tabele prawdy.
\small
\begin{center}
    \begin{tikzpicture}[node distance=2cm][H]
        
        \node (if_0) [decision] {Wyjście = 0};
        
        
        \node (if_start_1) [decision, right of=if_0,  xshift=2.5cm] {Start = 1};
        \node (in_start) [io, above of=if_start_1] {Start};

        \node (out_alarm) [io, below of=if_start_1, yshift=-0.5cm] {Alarm};

        \node (en_programming) [process, right of=if_start_1, xshift=2.5cm] {Załącz ustawianie};
        \node (in_time) [io, above of=en_programming] {Czas};

        \node (en_timer) [process, below of=if_0, yshift=-0.5cm] {Załącz kontroler licznika};
        \node (timer) [startstop, below of=en_timer] {Licznik};
        \node (out) [io, below of=timer] {Wyjście};
        
        
        \draw [arrow] (in_start) -- (if_start_1);
        \draw [arrow] (in_time) -- (en_programming);
        
        \draw [arrow] (if_0) -- node[anchor=south] {Tak} (if_start_1);
        \draw [arrow] (if_start_1) -- node[anchor=south] {Tak} (en_programming);
        \draw [arrow] (if_start_1) -- node[anchor=west] {Nie} (out_alarm);

        \draw [arrow] (if_0) -- node[anchor=west] {Nie} (en_timer);

        \draw [arrow] (en_timer) -- node[anchor=west] {Kontrola przerzutników} (timer);
        \draw [arrow] (en_programming) |- node[anchor=north] {Ustawienie przerzutników} (timer);

        \draw[arrow] (timer) -- (out);

        \draw [thick, ->] (out.south) -- ++(0, -1cm) -| node[anchor=north] {Odliczanie}  ++ (-3cm, 0) |- (if_0.west);
    \end{tikzpicture}
    \captionof{figure}{Diagram załączania układów}
\end{center}
\Large

\subsection{Kontrola działania licznika}
Na najwyższym poziomie nasz układ \verb|timer| składa się z dwóch podukładów: \verb|timer_setter| - układu ustawiającego czas odliczania
oraz \verb|timer_driver| układu kontrolującego wejścia T przerzutników. Na tym samym poziomie znajdują się 
przerzutniki stanowiące faktyczny licznik oraz implementacja formuł załączających te układy opisanych tutaj.

Dla czytelności poniżej przyjmujemy następujące oznaczenia:
\begin{itemize}
    \item \verb|EN_SET| - wejście aktywujące w układzie \verb|timer_setter|
    \item \verb|EN_DRV| - wejście aktywujące w układzie \verb|timer_driver|
    \item \verb|EQ0| - wyjście układu \verb|timer_driver| mówiące o tym czy obecny stan licznika to 0 (stan wysoki).
    \item \verb|START| - wejście startowe timera
\end{itemize}

\subsubsection{Tablice prawdy}

Tabela prawdy wynika z schematu kontroli przedstawionego powyżej.
\begin{center}
    \begin{tabular}{|c|c||c|c|}
    \hline \multicolumn{2}{|c||}{Wejście} & \multicolumn{2}{|c|}{Wyjście} \\
    \hline \verb|EQ0| & \verb|START| & \verb|EN_SET| & \verb|EN_DRV| \\
    \hline 0 & 0 & 0 & 1 \\
    \hline 0 & 1 & 0 & 1 \\
    \hline 1 & 0 & 0 & 0 \\
    \hline 1 & 1 & 1 & 0 \\
    \hline 
    \end{tabular}
    \captionof{table}{Tabela prawdy dla stanów aktywacji podukładów} 
\end{center}

\subsubsection{Wyprowadzenie formuł}
Dla wyjścia \verb|EN_SET| możemy odczytać formułę w prost z tabeli:
\[ \verb|EN_SET| = \verb|EQ0| \cdot \verb|START|  \] 
Dla wyjścia \verb|EN_DRV| możemy pokusić się o próbę optymalizacji formuły
przy pomocy tablicy Karnaugh:
\begin{center}
    \begin{karnaugh-map}[2][2][1][$\texttt{START}$][$\texttt{EQ0}$]
      \manualterms{1,1,0,0}
      \implicant{0}{1}
    \end{karnaugh-map}
    \captionof{table}{Tablica Karanugh dla formuły aktywującej układ kontrolujący licznik} 
\end{center}
Możemy z niej odczytać zoptymalizowaną formułę:
\[ \verb|EN_DRV| = \textcolor{red}{\overline{\texttt{EQ0}}} \]

\pagebreak
\subsubsection{Realizacja formuł}
Poniżej przedstawiamy realizację wcześniej wyprowadzonych formuł:
\[ \verb|EN_SET| = \verb|EQ0| \cdot \verb|START|  \] 
\[ \verb|EN_DRV| = \overline{\texttt{EQ0}} \]
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{timer_subsheet.pdf}
    \captionof{figure}{Ogólny schemat timera}
\end{figure}
Na schemacie znajdują się również rezystory pull-down zabezpieczające wejścia układu przed 
nieokreślonym stanem wejść.

\pagebreak
\subsection{Podukład ustawiający czas licznika}
Układ nazwany na naszych schematach \verb|timer_setter| ustawia czas odliczania 
gdy układ zostanie załączony. Układ ma na celu wysterowanie asynchronicznych wejść przerzutników T
poprzez odpowiednie wykonanie operacji SET lub RESET w zależności od obecnego stanu przerzutnika w 
porównaniu do odpowiadającego bitu programowania.

\subsubsection{Wejścia i Wyjścia}
Wejścia do układu stanowią bity oznaczające obecny stan poszczególnych wyjść przerzutnika, bity
oznaczające stan wejścia programowania timera oraz sygnał załączający układ. Wyjścia natomiast 
stanowią pary pinów SET i RESET dla poszczególnych przerzutników. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{timer_setter_black_box.png}
    \captionof{figure}{Czarna skrzynka podukładu time\_setter}
\end{figure}
Poniżej opis wejść układu:
\begin{itemize}
    \item \verb|EN| - wejście aktywujące układ, gdy wejście jest w stanie wysokim, na wyjściach układu
            pojawiają się odpowiednie wartości
    \item \verb|Qx| - wejścia obecnego stanu licznika, \verb|Q0| stanowi najmniej znaczący bit obecnego stanu licznika,
            a \verb|Q3| najbardziej znaczący bit.
    \item \verb|INx| - wejścia programowania startowego stanu licznika, \verb|IN0| stanowi najmniej znaczący bit wejścia,
            a \verb|IN3| najbardziej znaczący bit.
\end{itemize}

Poniżej opis wyjść układu:
\begin{itemize}
    \item \verb|Sx| - wyjście SET ustawiające odpowiedni przerzutnik T, wartość \verb|S0| obliczana
            jest na podstawie wejść \verb|Q0| i \verb|IN0|, a więc odpowiada ustawieniu przerzutnika T
            odpowiadającemu najmniej znaczącemu bitowi licznika.
    \item \verb|Rx| - wyjście RESET resetujący odpowiedni przerzutnik T, wartość \verb|R0| obliczana
            jest na podstawie wejść \verb|Q0| i \verb|IN0|, a więc odpowiada resetowaniu przerzutnika T
            odpowiadającemu najmniej znaczącemu bitowi licznika.
\end{itemize}

\subsubsection{Tabele prawdy}
Jako że, układ oblicza każdą parę wyjść dokładnie tak samo na podstawie odpowiadających sobie bitów,
tabelę prawdy zapiszemy w postaci sparametryzowanej, tzn. parze wyjściowej \verb|Sx|, \verb|Rx| odpowiadają
wejścia \verb|INx|, \verb|Qx| oraz sygnał enable. Finalnie ostateczny układ stanowią 4 powtórzone takie formuły 
dla każdego z bitów 0,1,2,3.

Tabela prawdy wynika z następujących faktów:
\begin{itemize}
    \item jeśli $ \verb|EN| = 0 $ to żadne wyjście nie jest aktywne
    \item jeśli $ \verb|INx| = \verb|Qx| $ to nie musimy zmieniać stanu przerzutnika
    \item w pozostałych przypadków wykonujemy odpowiednio albo operację SET albo RESET
\end{itemize}

\begin{center}
    \begin{tabular}{|c|c|c||c|c|}
    \hline \multicolumn{3}{|c||}{Wejście} & \multicolumn{2}{|c|}{Wyjście} \\
    \hline \verb|EN| & \verb|INx| & \verb|Qx| &  \verb|Sx| & \verb|Rx| \\
    \hline 0 & 0 & 0 & 0 & 0 \\
    \hline 0 & 0 & 1 & 0 & 0 \\
    \hline 0 & 1 & 0 & 0 & 0 \\
    \hline 0 & 1 & 1 & 0 & 0 \\
    \hline 1 & 0 & 0 & 0 & 0 \\
    \hline 1 & 0 & 1 & 0 & 1 \\
    \hline 1 & 1 & 0 & 1 & 0 \\
    \hline 1 & 1 & 1 & 0 & 0 \\
    \hline 
    \end{tabular}
    \captionof{table}{Tabela prawdy dla układu programującego początkowy stan licznika} 
\end{center}

\subsubsection{Wyprowadzenie formuł}
Na podstawie tabli prawd możemy wyprowadzić formułę na wyjścia \verb|Sx| i \verb|Rx|
\[\verb|Sx| = \verb|EN| \cdot \verb|INx| \cdot \overline{\texttt{Qx}}\]
\[\verb|Rx| = \verb|EN| \cdot \overline{\texttt{INx}} \cdot \texttt{Qx}\]

\subsubsection{Realizacja formuł}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{timer_setter_subsheet.pdf}
    \captionof{figure}{Schemat podukładu: timer\_setter}
\end{figure}
Układ składa się z powielonej 4 razy implementacji powyżej wyprowadzonych formuł.


\subsection{Podukład kontrolujący przerzutniki}
Układ nazwany na naszych schematach \verb|timer_driver| kontroluje wejścia $T$ przerzutników.
\subsubsection{Black box}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{timer_driver_black_box.png}
    \captionof{figure}{Czarna skrzynka podukładu: time\_driver}
\end{figure}

\subsubsection{Wejścia i Wyjścia}
\subsubsection{Tabele prawdy}
\begin{center}
    \begin{tabular}{|l|l|l|l|l||l|l|l|l||l|l|l|l|}
    \hline
    &\multicolumn{4}{c||}{Stan Obecny} & \multicolumn{4}{|c||}{Stan Następny} & \multicolumn{4}{|c|}{Przerzutniki} \\\hline
       &$Q_{n_3}$ & $Q_{n_2}$ & $Q_{n_1}$ & $Q_{n_0}$ & $Q_{n_3+1}$ & $Q_{n_2+1}$ & $Q_{n_1+1}$ &$Q_{n_0+1}$ & $T_3$ & $T_2$ & $T_1$ & $T_0$ \\ \hline
    15 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
    14 & 1 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 & 1 \\ \hline
    13 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
    12 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 \\ \hline
    11 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
    10 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ \hline
    9  & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
    8  & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
    7  & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
    6  & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 1 \\ \hline
    5  & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
    4  & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\ \hline
    3  & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
    2  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ \hline
    1  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
    0  & 0 & 0 & 0 & 0 & x & x & x & x & x & x & x & x \\ \hline
    \end{tabular}
    \captionof{table}{Tabela prawdy z uwzględnieniem stanu następnego}
    \end{center}



    \begin{center}
        \begin{tabular}{|l|l|l|l|l||l|l|l|l|}
        \hline
        &\multicolumn{4}{c||}{Stan Obecny} & \multicolumn{4}{|c|}{Przerzutniki} \\\hline
           &$Q_{n_3}$ & $Q_{n_2}$ & $Q_{n_1}$ & $Q_{n_0}$ & $T_3$ & $T_2$ & $T_1$ & $T_0$ \\ \hline
        15 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\ \hline
        14 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\ \hline
        13 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
        12 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\ \hline
        11 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
        10 & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 1 \\ \hline
        9  & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
        8  & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ \hline
        7  & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\ \hline
        6  & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\ \hline
        5  & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
        4  & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\ \hline
        3  & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 \\ \hline
        2  & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 1 \\ \hline
        1  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
        0  & 0 & 0 & 0 & 0 & x & x & x & x \\ \hline
        \end{tabular}
        \captionof{table}{Tablea prawdy podukładu: time\_driver}
        \end{center}

\subsubsection{Wyprowadzenie formuł}
\begin{center}
    \begin{karnaugh-map}[4][4][1][$Q1Q0$][$Q3Q2$]
      \manualterms{x,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0}
      \implicantedge{0}{0}{8}{8}
    \end{karnaugh-map}
    \captionof{table}{Tabela Karnaugh dla przerzutnika $T_3$} 
  \end{center}
Możemy z niej odczytać zoptymalizowaną formułę:
\[ T_3 = \textcolor{red}{\overline{Q_2Q_1Q_0}}\]

\begin{center}
    \begin{karnaugh-map}[4][4][1][$Q1Q0$][$Q3Q2$]
      \manualterms{x,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0}
      \implicant{0}{8}
    \end{karnaugh-map}
    \captionof{table}{Tabela Karnaugh dla przerzutnika $T_2$} 
  \end{center}
Możemy z niej odczytać zoptymalizowaną formułę:
\[ T_2 = \textcolor{red}{\overline{Q_1Q_0}}\]

\begin{center}
    \begin{karnaugh-map}[4][4][1][$Q1Q0$][$Q3Q2$]
      \manualterms{x,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0}
      \implicantedge{0}{8}{2}{10}
    \end{karnaugh-map}
    \captionof{table}{Tabela Karnaugh dla przerzutnika $T_1$} 
  \end{center}
Możemy z niej odczytać zoptymalizowaną formułę:
\[ T_1 = \textcolor{red}{\overline{Q_0}}\]

\begin{center}
    \begin{karnaugh-map}[4][4][1][$Q1Q0$][$Q3Q2$]
      \manualterms{x,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
      \implicant{0}{10}
    \end{karnaugh-map}
    \captionof{table}{Tabela Karnaugh dla przerzutnika $T_0$} 
  \end{center}
Możemy z niej odczytać zoptymalizowaną formułę:
\[ T_0 = \textcolor{red}{1}\]

\subsubsection{Realizacja formuł}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{timer_driver.pdf}
    \captionof{figure}{Schemat podukładu: time\_driver}
\end{figure}
\[ T_0 = \textcolor{red}{1}\]
\[ T_1 = \textcolor{red}{\overline{Q_0}}\]
\[ T_2 = \textcolor{red}{\overline{Q_1Q_0}}\]
\[ T_3 = \textcolor{red}{\overline{Q_2Q_1Q_0}}\]


\section{Przykład implementacji układu w obwodzie}
% TODO: rysunek showup_scheme

\pagebreak
\section{Testy}
\subsection{Testy podukładów}
\subsection{Test timera}
Zdecydowaliśmy się przeprowadzić ogólny test układu timer - na najwyższym poziomie abstrakcji.
W tym celu zestawiliśmy układ składający się z generatora słów, naszego układu \verb|timer|, komparatora oraz analizatora
stanów logicznych. Generator słów obsługuje nasz timer zapewniając mu cykle zegara w kolejnych 
generowanych słowach oraz generujący dane porównawcze dla każdego cyklu.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{general_test.pdf}
    \captionof{figure}{Schemat układu testującego}
\end{figure}

Zastosowaliśmy przerzutnik JK próbkujący wyjście komparatora, gdy generator słów generuje wyjście R(READY)
oznaczające, że skończył on generować dane słowo. Pojawienie się stanu wysokiego na wejściu J przerzutnika JK
powoduje jego ustawienie, a pojawienie się stanu wysokiego na wyjściu K resetuje ten przerzutnik.

Do wygenerowanie pliku wejściowego dla generatora słów, napisaliśmy skrypt w języku python, który 
symuluje kolejne kroki odliczania timera w zmiennych i zapisuje je do pliku w formacie, który można zaimportować 
do multisima.

Poniżej kod skryptu generującego dane:
\small
\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
]{python}
f = open("test_data.dp", "w")
f.write("Data:\n")

##################################################################
# |SR_RESET|ALARM|OUT3|OUT2|OUT1|OUT0|CLK|START|IN3|IN2|IN1|IN0| #
##################################################################

class TestOutput: 
    def __init__(self):
        self.in_data = 0
        self.start = 0
        self.clk = 0
        self.output_data = 0
        self.alarm = 0
        self.reset_sr = 0

    def to_bin_string(self):
        input_binary = str(bin(self.in_data)).removeprefix("0b").rjust(4, '0')
        start_binary = str(bin(self.start)).removeprefix("0b")
        clk_binary = str(bin(self.clk)).removeprefix("0b")
        output_binary = str(bin(self.output_data)).removeprefix("0b").rjust(4, '0')
        alarm_binary = str(bin(self.alarm)).removeprefix("0b")
        reset_sr_binary = str(bin(self.reset_sr)).removeprefix("0b")

        return reset_sr_binary + alarm_binary + output_binary + clk_binary + start_binary + input_binary
    

    def to_hex_string(self, pad):
        hex_val = hex(int(self.to_bin_string(), 2))
        return hex_val.removeprefix("0x").rjust(pad, '0')


####################################
# Test cycle to reset JK flip flop #
####################################

reset_to = TestOutput()
reset_to.alarm = 1
reset_to.reset_sr = 1
f.write(reset_to.to_hex_string(8) + "\n")
f.write(reset_to.to_hex_string(8) + "\n")
reset_to.reset_sr = 0
f.write(reset_to.to_hex_string(8) + "\n")
data_count = 3

for i in range(16):
    to = TestOutput()
    to.in_data = i
    to.start = 1
    to.output_data = i 
    to.alarm = int(i == 0)

    f.write(to.to_hex_string(8) + "\n")
    data_count += 1

    to.in_data = 0
    to.start = 0
    to.alarm = int(i == 0)

    for k in range(i):
        to.clk = 1
        to.output_data -= 1
        if to.output_data == 0:
            to.alarm = 1

        f.write(to.to_hex_string(8) + "\n")
        data_count += 1

        to.clk = 0

        f.write(to.to_hex_string(8) + "\n")
        data_count += 1

    f.write(to.to_hex_string(8) + "\n")
    data_count += 1

f.write("Initial:\n")
f.write("0000\n")
f.write("Final:\n")
f.write(str(hex(data_count)).capitalize().removeprefix("0x").rjust(4, '0'))

f.close()
\end{minted}
\captionof{figure}{Skrypt generujący dane do testów, napisany w języku Python}
\Large
W wyniku testu otrzymujemy informację poprzez zaświecenie się lampki jeśli gdziekolwiek wystąpił błąd oraz 
przebieg sygnałów z analizatora stanów logicznych:
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{general_test_logic_analyzer.png}
    \captionof{figure}{Przebieg sygnałów w analizatorze stanów logicznych}
\end{figure}
\pagebreak
\section{Zastosowania}
\begin{itemize}
    \item Sprzętowa obsługa timerów na mikroprocesorach, wraz z mechanizmem sprzętowych przerwań stanowią przydatny mechanizm
            pozwalający na cykliczne wywoływanie zadanego kodu bez konieczności zużywania czasu procesora na kontrolę upływu 
            czasu. Mechanizm taki ma zastosowanie od wspomnianego cyklicznego wykonywania kodu do sprzężenia ze sobą różnych peryferiów
            mikroprocesora, pozwalające na automatyczne dokonywanie cyklicznych pomiarów czy generowanie sygnałów, jak np. 
            sygnał Alarm timera podpięty jako sygnał wyzwalający konwersję przetwornika ADC, który odczyt zapisuje bezposrednio do pamięci
            poprzez mechanizm DMA czy timer generujący sygnał PWM przez porównanie obecnego stanu licznika z zadaną wartością - ponownie
            w sprzężeniu z mechanizmem DMA pozwalającym odczytywać kolejne wartości do porównania w każdym okresie timera bezpośrednio z pamięci
            można nadawać praktycznie dowolny sygnał cyfrowy.  % --TODO: moje rysunki z tableta
\end{itemize}
\section{Wnioski}
Dzięki przerzutnikom możemy projektować złożone układy z pamięcią swojego stanu. 

W toku rozwiązywania postawionego problemu opracowaliśmy kilka możliwych rozwiązań. Ostatecznie
zdecydowaliśmy się na przedstawienie tego konkretnego rozwiązania ze względu na jego prostotę i 
największą niezawodność. Zastosowanie przerzutników działających synchronicznie pozwoliło na zredukowanie
ilości hazardów przy odliczaniu czasu.

Innym sposobem było: <tu opis rozwiązanie Kacpra i schemat> % TODO: opis + schemat

Pierwotnym pomysłem było użycie przerzutników T asynchronicznie - łącząc je w szeregowo dzięki czemu 
nie było konieczne projektowanie układu kontrolującego przerzutniki. Największą wadą tego rozwiązania
było to, że otoczka sterowania tak połączonych przerzutników była trudna do przedstawienia wzorami i 
uzasadnienia w prosty sposób. Rozwiązanie opierało się na idei generowania kolejnych impulsów 
synchronizujących kolejne etapy przygotowania i uruchomienia układu.

<tu mój schemat> % TODO: schemat

\end{document}


